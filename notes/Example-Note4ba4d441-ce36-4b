{"type":"doc","content":[{"type":"heading","attrs":{"textAlign":"left","id":"heading-1","level":1},"content":[{"type":"text","text":"Backtracking"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Always sketch out the recursion tree in backtracking problems, solving becomes easy from there"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-2","level":2},"content":[{"type":"text","text":"String Partitioning"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Partition a string into all possible substrings"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Uses recursive calls to partition and check whatever valid condition needs to be checked (eg. is a palindrome, is present in a dictionary etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems "}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Palindrome Partitioning"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/palindrome-partitioning/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/palindrome-partitioning/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is palindrome"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Word Break II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/word-break-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/word-break-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is present in dictionary"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(s)\n\ndef backtrack(curr_partition, start):\n    if start == n:\n        result.append(curr_partition)\n        return\n    \n    for end in range(start + 1, n + 1):\n        substring = s[start:end]\n        if is_valid_substring(substring): #is_valid_substring changes with the type of problem at hand\n            curr_partition.append(substring)\n            backtrack(curr_partition, end) #Can also use backtrack(curr_partition + [substring], end)\n            curr_partition.pop()\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"s"},{"type":"text","text":": The input string to be partitioned."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":": A function that checks if a given substring is valid (e.g., checks if it is a palindrome or if it is in a dictionary)."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the valid partitions."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_partition"},{"type":"text","text":": The current partition being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for partitioning the string."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" reaches the end of the string ("},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":"), we add the current partition to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through possible end indices ("},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":"), generate substrings from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":", and check if they are valid using the "},{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":" function. If valid, we recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the new substring added to the current partition. After the recursive call, we backtrack by removing the last added substring."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-3","level":2},"content":[{"type":"text","text":"Subsets"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Recursively generate all subsets from a given set"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can use 2 principles, 1st is for loop (so subsets starting with element) and 2nd is inclusion exclusion (Add curr to result only at the end)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can slightly modify the logic on what subsets to include based on any conditions (duplicates etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicate Subsets"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_subset, start):\n    # Add the current subset to the result\n    result.append(list(curr_subset))\n    \n    for i in range(start, n):\n        # Include the current element\n        curr_subset.append(nums[i])\n        # Move to the next element\n        backtrack(curr_subset, i + 1)\n        # Exclude the current element (backtrack)\n        curr_subset.pop()\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers from which to generate subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":": The current subset being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for the next element to consider."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": Every time we call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":", we add the current subset ("},{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":") to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through the elements starting from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", include the current element in the subset, and recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the next starting index. After the recursive call, we backtrack by removing the last added element to explore other subsets."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-4","level":2},"content":[{"type":"text","text":"Permutations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Just a slight variation of the combinations problem"}]}]}]}]}