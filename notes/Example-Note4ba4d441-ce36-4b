{"type":"doc","content":[{"type":"heading","attrs":{"textAlign":"left","id":"heading-1","level":1},"content":[{"type":"text","text":"Backtracking"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Always sketch out the recursion tree in backtracking problems, solving becomes easy from there"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-2","level":2},"content":[{"type":"text","text":"String Partitioning"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Partition a string into all possible substrings"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Uses recursive calls to partition and check whatever valid condition needs to be checked (eg. is a palindrome, is present in a dictionary etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems "}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Palindrome Partitioning"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/palindrome-partitioning/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/palindrome-partitioning/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is palindrome"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Word Break II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/word-break-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/word-break-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is present in dictionary"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(s)\n\ndef backtrack(curr_partition, start):\n    if start == n:\n        result.append(curr_partition)\n        return\n    \n    for end in range(start + 1, n + 1):\n        substring = s[start:end]\n        if is_valid_substring(substring): #is_valid_substring changes with the type of problem at hand\n            curr_partition.append(substring)\n            backtrack(curr_partition, end) #Can also use backtrack(curr_partition + [substring], end)\n            curr_partition.pop()\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"s"},{"type":"text","text":": The input string to be partitioned."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":": A function that checks if a given substring is valid (e.g., checks if it is a palindrome or if it is in a dictionary)."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the valid partitions."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_partition"},{"type":"text","text":": The current partition being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for partitioning the string."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" reaches the end of the string ("},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":"), we add the current partition to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through possible end indices ("},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":"), generate substrings from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":", and check if they are valid using the "},{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":" function. If valid, we recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the new substring added to the current partition. After the recursive call, we backtrack by removing the last added substring."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-3","level":2},"content":[{"type":"text","text":"Subsets"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Recursively generate all subsets from a given set"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can use 2 principles, 1st is for loop (so subsets starting with element) and 2nd is inclusion exclusion (Add curr to result only at the end)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"It is better to use inclusion/exclusion when you want all subsets without any restrictions (combination sum, original subsets problem etc.), otherwise when you have restrictions (length, no duplicates etc.), it is better to use for loop strategy"}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can slightly modify the logic on what subsets to include based on any conditions (duplicates etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicate Subsets"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combinations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combinations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combinations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets of length k"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Repetition Allowed"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Repetition "}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_subset, start):\n    result.append(list(curr_subset))\n    \n    for i in range(start, n):\n        curr_subset.append(nums[i]) # Add the current subset to the result\n        backtrack(curr_subset, i + 1) # Move to the next element\n        curr_subset.pop() # Exclude the current element (backtrack)\n\nbacktrack([], 0)\nreturn result"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn= = len(nums)\n\ndef backtrack(curr, i):\n    if i == n: # Base case: if we've considered all elements\n        result.append(curr)  \n        return\n\n    dfs(curr + [nums[i]], i + 1) # Inclusion: include nums[i] in the subset\n    dfs(curr, i + 1) # Exclusion: exclude nums[i] from the subset\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers from which to generate subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":": The current subset being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for the next element to consider."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": Every time we call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":", we add the current subset ("},{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":") to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through the elements starting from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", include the current element in the subset, and recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the next starting index. After the recursive call, we backtrack by removing the last added element to explore other subsets."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-4","level":2},"content":[{"type":"text","text":"Code to identify non repeating elements in an array"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"prev = None\n\nfor i in range(n):\n    if arr[i] != prev:\n        # Do something with the unique element 'arr[i]'\n        print(arr[i])  # Replace this with your desired operation\n    prev = arr[i]\n\n# Or easier, just use continue statement, if arr[i]==arr[i-1]: continue"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-5","level":2},"content":[{"type":"text","text":"Permutations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Just a slight variation of the combinations problem. Permutations generate all possible orders of elements in a given set. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The idea is to explore every possible order by fixing one element at a time and recursively permuting the remaining elements."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems:"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations-ii/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations-ii/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicates"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_permutation, used):\n    if len(curr_permutation) == n: # Base case: if the current permutation is of length n, add it to result\n        result.append(list(curr_permutation))\n        return\n    \n    for i in range(n): \n        if used[i]: # Skip already used elements\n            continue\n\n        used[i] = True # Mark the current element as used\n        curr_permutation.append(nums[i]) \n        backtrack(curr_permutation, used) # Recurse with the updated permutation and used status\n        used[i] = False # Backtrack: unmark the element and remove it from the current permutation\n        curr_permutation.pop() \n\nbacktrack([], [False] * n)\nreturn result\n\n#You can maintain used, or just directly check if nums[i] is present in curr (this is O(n)), and if yes, just skip it. "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers for which we want to generate permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" "},{"type":"text","marks":[{"type":"bold"}],"text":"Function"},{"type":"text","text":": A helper function to perform the actual backtracking."}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":": The current permutation being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"used"},{"type":"text","text":": A boolean list to keep track of which elements are used in the current permutation."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If the length of "},{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":" is equal to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", the current permutation is added to the result."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": Iterate through the elements, check if the current element is used, and recursively generate permutations with the rest of the elements. After the recursive call, backtrack by marking the element as unused and removing it from the permutation."}]}]}]}]}