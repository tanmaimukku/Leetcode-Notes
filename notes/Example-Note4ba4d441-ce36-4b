{"type":"doc","content":[{"type":"heading","attrs":{"textAlign":"left","id":"heading-1","level":1},"content":[{"type":"text","text":"Backtracking"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Always sketch out the recursion tree in backtracking problems, solving becomes easy from there"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-2","level":2},"content":[{"type":"text","text":"String Partitioning"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Partition a string into all possible substrings"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Uses recursive calls to partition and check whatever valid condition needs to be checked (eg. is a palindrome, is present in a dictionary etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems "}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Palindrome Partitioning"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/palindrome-partitioning/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/palindrome-partitioning/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is palindrome"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Word Break II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/word-break-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/word-break-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is present in dictionary"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(s)\n\ndef backtrack(curr_partition, start):\n    if start == n:\n        result.append(curr_partition)\n        return\n    \n    for end in range(start + 1, n + 1):\n        substring = s[start:end]\n        if is_valid_substring(substring): #is_valid_substring changes with the type of problem at hand\n            curr_partition.append(substring)\n            backtrack(curr_partition, end) #Can also use backtrack(curr_partition + [substring], end)\n            curr_partition.pop()\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"s"},{"type":"text","text":": The input string to be partitioned."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":": A function that checks if a given substring is valid (e.g., checks if it is a palindrome or if it is in a dictionary)."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the valid partitions."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_partition"},{"type":"text","text":": The current partition being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for partitioning the string."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" reaches the end of the string ("},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":"), we add the current partition to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through possible end indices ("},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":"), generate substrings from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":", and check if they are valid using the "},{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":" function. If valid, we recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the new substring added to the current partition. After the recursive call, we backtrack by removing the last added substring."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-3","level":2},"content":[{"type":"text","text":"Subsets"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Recursively generate all subsets from a given set"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can use 2 principles, 1st is for loop (so subsets starting with element) and 2nd is inclusion exclusion (Add curr to result only at the end)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"It is better to use inclusion/exclusion when you want all subsets without any restrictions (combination sum, original subsets problem etc.), otherwise when you have restrictions (length, no duplicates etc.), it is better to use for loop strategy"}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can slightly modify the logic on what subsets to include based on any conditions (duplicates etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicate Subsets"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combinations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combinations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combinations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets of length k"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Repetition Allowed"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Repetition "}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_subset, start):\n    result.append(list(curr_subset))\n    \n    for i in range(start, n):\n        curr_subset.append(nums[i]) # Add the current subset to the result\n        backtrack(curr_subset, i + 1) # Move to the next element\n        curr_subset.pop() # Exclude the current element (backtrack)\n\nbacktrack([], 0)\nreturn result"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn= = len(nums)\n\ndef backtrack(curr, i):\n    if i == n: # Base case: if we've considered all elements\n        result.append(curr)  \n        return\n\n    dfs(curr + [nums[i]], i + 1) # Inclusion: include nums[i] in the subset\n    dfs(curr, i + 1) # Exclusion: exclude nums[i] from the subset\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers from which to generate subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":": The current subset being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for the next element to consider."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": Every time we call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":", we add the current subset ("},{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":") to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through the elements starting from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", include the current element in the subset, and recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the next starting index. After the recursive call, we backtrack by removing the last added element to explore other subsets."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-4","level":2},"content":[{"type":"text","text":"Code to identify non repeating elements in an array"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"prev = None\n\nfor i in range(n):\n    if arr[i] != prev:\n        # Do something with the unique element 'arr[i]'\n        print(arr[i])  # Replace this with your desired operation\n    prev = arr[i]\n\n# Or easier, just use continue statement, if arr[i]==arr[i-1]: continue"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-5","level":2},"content":[{"type":"text","text":"Permutations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Just a slight variation of the combinations problem. Permutations generate all possible orders of elements in a given set. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The idea is to explore every possible order by fixing one element at a time and recursively permuting the remaining elements."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems:"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations-ii/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations-ii/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicates"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_permutation, used):\n    if len(curr_permutation) == n: # Base case: if the current permutation is of length n, add it to result\n        result.append(list(curr_permutation))\n        return\n    \n    for i in range(n): \n        if used[i]: # Skip already used elements\n            continue\n\n        used[i] = True # Mark the current element as used\n        curr_permutation.append(nums[i]) \n        backtrack(curr_permutation, used) # Recurse with the updated permutation and used status\n        used[i] = False # Backtrack: unmark the element and remove it from the current permutation\n        curr_permutation.pop() \n\nbacktrack([], [False] * n)\nreturn result\n\n#You can maintain used, or just directly check if nums[i] is present in curr (this is O(n)), and if yes, just skip it. "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers for which we want to generate permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" "},{"type":"text","marks":[{"type":"bold"}],"text":"Function"},{"type":"text","text":": A helper function to perform the actual backtracking."}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":": The current permutation being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"used"},{"type":"text","text":": A boolean list to keep track of which elements are used in the current permutation."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If the length of "},{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":" is equal to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", the current permutation is added to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": Iterate through the elements, check if the current element is used, and recursively generate permutations with the rest of the elements. After the recursive call, backtrack by marking the element as unused and removing it from the permutation."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-6","level":2},"content":[{"type":"text","text":"Constructing Valid Configurations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Construct valid solutions that adhere to specific constraints (like placing elements on a grid)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems:"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"N-Queens"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/n-queens/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/n-queens/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sudoku Solver"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/sudoku-solver/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/sudoku-solver/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def is_valid(inputs):\n    #Check the validity (n-queens is valid, sudoku board is valid etc.)\ndef backtrack(inputs):\n    \n    #the outer loops can changem this template is not 100% fitting, just for idea\n    #for loop (whatever you want to loop on)\n        if is_valid(inputs):\n            board[row][col] = 'Q'  # Place queen (In case of sudoku, its number)\n            #backtrack\n            board[row][col] = '.'  # Backtrack (remove queen/number)\n\nbacktrack(inputs)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"textStyle","attrs":{"fontFamily":null,"color":"#f03e3e","fontSize":13}}],"text":"Note"},{"type":"text","text":": Have to write code templates for dynamic programming + backtracking, DFS/BFS + backtracking. Mostly will be covered in DP and graph subsections. "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"textStyle","attrs":{"fontFamily":null,"color":"#f03e3e","fontSize":13}}],"text":"Note"},{"type":"text","text":": There's also problems like valid parentheses, that don't fall into any of the patterns listed above, but it's just general backtracking and knowing when to stop (opening brackets >= closing brackets)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-7","level":1},"content":[{"type":"text","text":"Graphs"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Most leetcode problems in graphs are either adjacency lists, or grid based problems. Occasionally, you might encounter graphs represented using Nodes, and graphs represented using adjacency matrix. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Try to pass both the graph, visited set as arguments to the function, as in Python, only references to mutable objects are passed, so it is the same object, not a copy. "}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-8","level":2},"content":[{"type":"text","text":"Converting edges to adjacency list"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def edge_list_to_adj_list(edges: list, n: int):\n    # Create an empty adjacency list with default as an empty list\n    adj_list = defaultdict(list)\n    \n    # Iterate over the edge list to populate the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)  # If the graph is undirected, add both ways\n    \n    return adj_list"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-9","level":2},"content":[{"type":"text","text":"DFS"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"DFS magic spell: 1]push to stack, 2] pop top , 3] retrieve unvisited neighbours of top, push them to stack 4] repeat 1,2,3 while stack not empty. Now form a rap !"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-10","level":2},"content":[{"type":"text","text":"Recursive DFS (adjacency list)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(node: int, visited: set, graph: dict):\n    # Mark the current node as visited\n    visited.add(node)\n    \n    # Process the current node (e.g., print, collect data, etc.)\n    print(f\"Visiting node {node}\")\n    \n    # Recursively visit all unvisited neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(neighbor, visited, graph)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-11","level":2},"content":[{"type":"text","text":"Recursive DFS (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(x: int, y: int, visited: set, grid: list):\n    # Mark the current cell as visited\n    visited.add((x, y))\n    \n    # Process the current cell (e.g., print, collect data, etc.)\n    print(f\"Visiting cell ({x}, {y})\")\n    \n    # Define the directions for neighbors: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Get the grid dimensions\n    rows, cols = len(grid), len(grid[0])\n    \n    # Recursively visit all unvisited neighbors within bounds\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: #Here you can add additional conditions, like edge exists only if it is a 1 etc.\n            dfs(nx, ny, visited, grid)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-12","level":2},"content":[{"type":"text","text":"Iterative DFS (adjacency list)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited nodes\nstack = [start]  # Initialize the stack with the starting node\n\nwhile stack:\n    node = stack.pop()  # Pop the last node added (LIFO order)\n\n    if node not in visited:\n        # Mark the node as visited\n        visited.add(node)\n        print(f\"Visiting node {node}\")\n\n        # Push all unvisited neighbors onto the stack\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-13","level":2},"content":[{"type":"text","text":"Iterative DFS (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited cells\nstack = [(start_x, start_y)]  # Initialize the stack with the starting cell\n\n# Define the directions for neighbors: up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Get the grid dimensions\nrows, cols = len(grid), len(grid[0])\n\nwhile stack:\n    x, y = stack.pop()  # Pop the last cell added\n\n    if (x, y) not in visited:\n        # Mark the current cell as visited\n        visited.add((x, y))\n        print(f\"Visiting cell ({x}, {y})\")\n\n        # Push all unvisited neighbors onto the stack (within bounds)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                stack.append((nx, ny))"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-14","level":2},"content":[{"type":"text","text":"Recursive DFS to keep track of Path (adjacency list)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"This works both in cyclic and acyclic graphs, as in the "},{"type":"text","marks":[{"type":"bold"}],"text":"backtracking step"},{"type":"text","text":", we are removing the node from the visited set once we finish exploring its neighbors. This prevents the algorithm from getting stuck in an infinite loop caused by cycles while still allowing revisits to nodes in different paths."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(node, target, graph, visited, path, all_paths):\n    visited.add(node)\n    path.append(node)\n    \n    if node == target:\n        # If we've reached the target, store the current path\n        all_paths.append(list(path))\n    else:\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs_with_path(neighbor, target, graph, visited, path, all_paths)\n    \n    path.pop()  # Backtrack\n    visited.remove(node)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-15","level":2},"content":[{"type":"text","text":"Recursive DFS to keep track of Path (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(x, y, target_x, target_y, grid, visited, path, all_paths):\n    # Add current cell to the path and mark it as visited\n    path.append((x, y))\n    visited.add((x, y))\n    \n    # If we reach the target cell, store the current path\n    if (x, y) == (target_x, target_y):\n        all_paths.append(list(path))  # Store a copy of the path\n    else:\n        # Explore the 4 possible directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        rows, cols = len(grid), len(grid[0])\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            # Check if the next cell is within bounds and not visited\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 1:\n                dfs(nx, ny, target_x, target_y, grid, visited, path, all_paths)\n    \n    # Backtrack: remove the current cell from the path and unmark it as visited\n    path.pop()\n    visited.remove((x, y))"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-16","level":2},"content":[{"type":"text","text":"Recursive DFS for topological sort"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Key point is, Once all neighbors of the current node have been processed, the current node is added to the stack."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"After performing DFS on all unvisited nodes, the stack will contain the nodes in reverse topological order (because nodes are pushed to the stack after their dependencies have been processed)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Result"},{"type":"text","text":": The topological order is obtained by reversing the stack."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Some important points: This code will only work if there is no cycle, i.e , incase of a DAG. If you want it to work even when cycles are there, and return empty array if cycles are there, you need to add cycle detection logic. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs_topological(node, graph, visited, stack):\n    visited.add(node)  # Mark the current node as visited\n\n    # Recursively visit all unvisited neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_topological(neighbor, graph, visited, stack)\n    \n    # After all neighbors are processed, add the current node to the stack\n    stack.append(node)\n\nvisited = set()  # Set to keep track of visited nodes\nstack = []  # Stack to store the topological order\n\n# Perform DFS from every node to ensure all nodes are visited\nfor node in range(n):\n    if node not in visited:\n        dfs_topological(node, graph, visited, stack)\n\n# The topological order is the reverse of the DFS post-order traversal\nreturn stack[::-1] "}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-17","level":2},"content":[{"type":"text","text":"Recursive DFS for Cycle Detection"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Cycle detection is based on the Key point: In the current path, if there is back edge, i.e, node connecting to any previous nodes only in the current path, there is a cycle. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"You cannot use visited to keep track of cycles, i.e claim that if we revisit the node there is a cycle, as a node maybe visited multiple times in DFS. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"You also can't check something like if node in recursion_stack at the very beginning, because we will never visit the same node again due to us keeping track of visited. So that statement would never be True. So we always have to keep the main logic as detecting back edge. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs_cycle(node, graph, visited, recursion_stack):\n    visited.add(node)  # Mark the node as visited\n    recursion_stack.add(node)  # Add the node to the current recursion stack\n\n    # Explore the neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs_cycle(neighbor, graph, visited, recursion_stack):\n                return True  # Cycle detected (If you don't do this, True won't be propogated)\n        elif neighbor in recursion_stack:\n            return True  # Cycle detected (back edge found)\n\n    # Backtrack: remove the node from the recursion stack\n    recursion_stack.remove(node)\n    return False"}]}]}