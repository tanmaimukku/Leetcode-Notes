{"type":"doc","content":[{"type":"heading","attrs":{"textAlign":"left","id":"heading-1","level":1},"content":[{"type":"text","text":"Contents"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Backtracking"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-2","level":1},"content":[{"type":"text","text":"Backtracking"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Always sketch out the recursion tree in backtracking problems, solving becomes easy from there"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-3","level":2},"content":[{"type":"text","text":"String Partitioning"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Partition a string into all possible substrings"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Uses recursive calls to partition and check whatever valid condition needs to be checked (eg. is a palindrome, is present in a dictionary etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems "}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Palindrome Partitioning"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/palindrome-partitioning/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/palindrome-partitioning/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is palindrome"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Word Break II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/word-break-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/word-break-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"condition is present in dictionary"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(s)\n\ndef backtrack(curr_partition, start):\n    if start == n:\n        result.append(curr_partition)\n        return\n    \n    for end in range(start + 1, n + 1):\n        substring = s[start:end]\n        if is_valid_substring(substring): #is_valid_substring changes with the type of problem at hand\n            curr_partition.append(substring)\n            backtrack(curr_partition, end) #Can also use backtrack(curr_partition + [substring], end)\n            curr_partition.pop()\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"s"},{"type":"text","text":": The input string to be partitioned."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":": A function that checks if a given substring is valid (e.g., checks if it is a palindrome or if it is in a dictionary)."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the valid partitions."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_partition"},{"type":"text","text":": The current partition being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for partitioning the string."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" reaches the end of the string ("},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":"), we add the current partition to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through possible end indices ("},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":"), generate substrings from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"end"},{"type":"text","text":", and check if they are valid using the "},{"type":"text","marks":[{"type":"code"}],"text":"is_valid_substring"},{"type":"text","text":" function. If valid, we recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the new substring added to the current partition. After the recursive call, we backtrack by removing the last added substring."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-4","level":2},"content":[{"type":"text","text":"Subsets"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Recursively generate all subsets from a given set"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can use 2 principles, 1st is for loop (so subsets starting with element) and 2nd is inclusion exclusion (Add curr to result only at the end)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"It is better to use inclusion/exclusion when you want all subsets without any restrictions (combination sum, original subsets problem etc.), otherwise when you have restrictions (length, no duplicates etc.), it is better to use for loop strategy"}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Can slightly modify the logic on what subsets to include based on any conditions (duplicates etc.)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/subsets-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/subsets-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicate Subsets"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combinations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combinations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combinations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Subsets of length k"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Repetition Allowed"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Combination Sum II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/combination-sum-ii/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/combination-sum-ii/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Repetition "}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_subset, start):\n    result.append(list(curr_subset))\n    \n    for i in range(start, n):\n        curr_subset.append(nums[i]) # Add the current subset to the result\n        backtrack(curr_subset, i + 1) # Move to the next element\n        curr_subset.pop() # Exclude the current element (backtrack)\n\nbacktrack([], 0)\nreturn result"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn= = len(nums)\n\ndef backtrack(curr, i):\n    if i == n: # Base case: if we've considered all elements\n        result.append(curr)  \n        return\n\n    dfs(curr + [nums[i]], i + 1) # Inclusion: include nums[i] in the subset\n    dfs(curr, i + 1) # Exclusion: exclude nums[i] from the subset\n\nbacktrack([], 0)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers from which to generate subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the subsets."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","marks":[{"type":"bold"}],"text":" Function"},{"type":"text","text":": A helper function that performs the actual backtracking."}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":": The current subset being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":": The starting index for the next element to consider."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": Every time we call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":", we add the current subset ("},{"type":"text","marks":[{"type":"code"}],"text":"curr_subset"},{"type":"text","text":") to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": We iterate through the elements starting from "},{"type":"text","marks":[{"type":"code"}],"text":"start"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", include the current element in the subset, and recursively call "},{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" with the next starting index. After the recursive call, we backtrack by removing the last added element to explore other subsets."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-5","level":2},"content":[{"type":"text","text":"Code to identify non repeating elements in an array"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"prev = None\n\nfor i in range(n):\n    if arr[i] != prev:\n        # Do something with the unique element 'arr[i]'\n        print(arr[i])  # Replace this with your desired operation\n    prev = arr[i]\n\n# Or easier, just use continue statement, if arr[i]==arr[i-1]: continue"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-6","level":2},"content":[{"type":"text","text":"Permutations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Just a slight variation of the combinations problem. Permutations generate all possible orders of elements in a given set. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The idea is to explore every possible order by fixing one element at a time and recursively permuting the remaining elements."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example problems:"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Permutations II"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/permutations-ii/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/permutations-ii/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No Duplicates"}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"result = []\nn = len(nums)\n\ndef backtrack(curr_permutation, used):\n    if len(curr_permutation) == n: # Base case: if the current permutation is of length n, add it to result\n        result.append(list(curr_permutation))\n        return\n    \n    for i in range(n): \n        if used[i]: # Skip already used elements\n            continue\n\n        used[i] = True # Mark the current element as used\n        curr_permutation.append(nums[i]) \n        backtrack(curr_permutation, used) # Recurse with the updated permutation and used status\n        used[i] = False # Backtrack: unmark the element and remove it from the current permutation\n        curr_permutation.pop() \n\nbacktrack([], [False] * n)\nreturn result\n\n#You can maintain used, or just directly check if nums[i] is present in curr (this is O(n)), and if yes, just skip it. "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"nums"},{"type":"text","text":": The input list of numbers for which we want to generate permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"result"},{"type":"text","text":": A list to store all the permutations."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"backtrack"},{"type":"text","text":" "},{"type":"text","marks":[{"type":"bold"}],"text":"Function"},{"type":"text","text":": A helper function to perform the actual backtracking."}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":": The current permutation being constructed."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"used"},{"type":"text","text":": A boolean list to keep track of which elements are used in the current permutation."}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Case"},{"type":"text","text":": If the length of "},{"type":"text","marks":[{"type":"code"}],"text":"curr_permutation"},{"type":"text","text":" is equal to "},{"type":"text","marks":[{"type":"code"}],"text":"n"},{"type":"text","text":", the current permutation is added to the result."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive Case"},{"type":"text","text":": Iterate through the elements, check if the current element is used, and recursively generate permutations with the rest of the elements. After the recursive call, backtrack by marking the element as unused and removing it from the permutation."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-7","level":2},"content":[{"type":"text","text":"Constructing Valid Configurations"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Construct valid solutions that adhere to specific constraints (like placing elements on a grid)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Example Problems:"}]},{"type":"table","content":[{"type":"tableRow","content":[{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problem"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Link"}]}]},{"type":"tableHeader","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Notes"}]}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"N-Queens"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/n-queens/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/n-queens/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]},{"type":"tableRow","content":[{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sudoku Solver"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/sudoku-solver/description/","target":"_blank","rel":"noopener noreferrer nofollow","class":null}}],"text":"https://leetcode.com/problems/sudoku-solver/description/"}]}]},{"type":"tableCell","attrs":{"colspan":1,"rowspan":1,"colwidth":null},"content":[{"type":"paragraph","attrs":{"textAlign":"left"}}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def is_valid(inputs):\n    #Check the validity (n-queens is valid, sudoku board is valid etc.)\ndef backtrack(inputs):\n    \n    #the outer loops can changem this template is not 100% fitting, just for idea\n    #for loop (whatever you want to loop on)\n        if is_valid(inputs):\n            board[row][col] = 'Q'  # Place queen (In case of sudoku, its number)\n            #backtrack\n            board[row][col] = '.'  # Backtrack (remove queen/number)\n\nbacktrack(inputs)\nreturn result"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"textStyle","attrs":{"fontFamily":null,"color":"#f03e3e","fontSize":13}}],"text":"Note"},{"type":"text","text":": Have to write code templates for dynamic programming + backtracking, DFS/BFS + backtracking. Mostly will be covered in DP and graph subsections. "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"textStyle","attrs":{"fontFamily":null,"color":"#f03e3e","fontSize":13}}],"text":"Note"},{"type":"text","text":": There's also problems like valid parentheses, that don't fall into any of the patterns listed above, but it's just general backtracking and knowing when to stop (opening brackets >= closing brackets)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-8","level":1},"content":[{"type":"text","text":"Graphs"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Most leetcode problems in graphs are either adjacency lists, or grid based problems. Occasionally, you might encounter graphs represented using Nodes, and graphs represented using adjacency matrix. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Try to pass both the graph, visited set as arguments to the function, as in Python, only references to mutable objects are passed, so it is the same object, not a copy. "}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-9","level":2},"content":[{"type":"text","text":"Converting edges to adjacency list"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def edge_list_to_adj_list(edges: list, n: int):\n    # Create an empty adjacency list with default as an empty list\n    adj_list = defaultdict(list)\n    \n    # Iterate over the edge list to populate the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)  # If the graph is undirected, add both ways\n    \n    return adj_list"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-10","level":2},"content":[{"type":"text","text":"DFS vs BFS"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-11","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"DFS"},{"type":"text","text":":"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Mark node as visited"},{"type":"text","text":": When "},{"type":"text","marks":[{"type":"bold"}],"text":"popped"},{"type":"text","text":" from the stack (ready to process). "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Why?"},{"type":"text","text":": Ensures full exploration of neighbors before marking as visited."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Additional visited check"},{"type":"text","text":": Needed before "},{"type":"text","marks":[{"type":"bold"}],"text":"pushing neighbors onto the stack"},{"type":"text","text":" to avoid pushing the same node multiple times (because DFS might revisit nodes from different branches). (Only in case of iterative)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Recursive DFS"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"No need for an additional visited check because the recursion stack inherently manages depth-first traversal, and nodes are marked as visited immediately when the function is called."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The call stack prevents revisiting nodes by the nature of recursion."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"In "},{"type":"text","marks":[{"type":"bold"}],"text":"recursive DFS"},{"type":"text","text":", you process the node first, recursively call neighbors, and only after all recursive calls are done does the node \"pop\" from the stack (when the function returns)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Iterative DFS"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Requires two visited checks:"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Before pushing neighbors"},{"type":"text","text":" onto the stack, to avoid pushing already visited nodes."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Before processing the node"},{"type":"text","text":" after popping from the stack, to ensure the node is only processed once, even if it's added to the stack multiple times from different paths."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"In "},{"type":"text","marks":[{"type":"bold"}],"text":"iterative DFS"},{"type":"text","text":", you pop the node first, process it, then push neighbors to the stack."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The difference arises from how the call stack in recursion automatically manages depth-first exploration compared to manual stack management in iterative DFS, so don't worry too much, just memorize. "}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-12","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"BFS"},{"type":"text","text":":"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Mark node as visited"},{"type":"text","text":": When "},{"type":"text","marks":[{"type":"bold"}],"text":"enqueued"},{"type":"text","text":" (immediately after adding to the queue)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Why?"},{"type":"text","text":": BFS processes nodes level by level, so marking when enqueuing prevents revisiting and ensures the shortest path is maintained."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"No additional visited check"},{"type":"text","text":": Since nodes are marked visited when enqueued, they won’t be added to the queue again, making an additional check after dequeuing unnecessary."}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-13","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Points"},{"type":"text","text":":"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"DFS"},{"type":"text","text":" explores deeply; multiple paths might push the same node, so check before pushing."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"BFS"},{"type":"text","text":" explores level by level; mark when enqueuing to ensure each node is processed once, in the correct order."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Efficiency"},{"type":"text","text":": BFS marking on enqueue is optimal for reducing redundant checks."}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-14","level":2},"content":[{"type":"text","text":"DFS"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"DFS magic spell: 1]push to stack, 2] pop top , 3] retrieve unvisited neighbours of top, push them to stack 4] repeat 1,2,3 while stack not empty. Now form a rap !"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-15","level":2},"content":[{"type":"text","text":"Recursive DFS (adjacency list)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(node: int, visited: set, graph: dict):\n    # Mark the current node as visited\n    visited.add(node)\n    \n    # Process the current node (e.g., print, collect data, etc.)\n    print(f\"Visiting node {node}\")\n    \n    # Recursively visit all unvisited neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(neighbor, visited, graph)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-16","level":2},"content":[{"type":"text","text":"Recursive DFS (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(x: int, y: int, visited: set, grid: list):\n    # Mark the current cell as visited\n    visited.add((x, y))\n    \n    # Process the current cell (e.g., print, collect data, etc.)\n    print(f\"Visiting cell ({x}, {y})\")\n    \n    # Define the directions for neighbors: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Get the grid dimensions\n    rows, cols = len(grid), len(grid[0])\n    \n    # Recursively visit all unvisited neighbors within bounds\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: #Here you can add additional conditions, like edge exists only if it is a 1 etc.\n            dfs(nx, ny, visited, grid)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-17","level":2},"content":[{"type":"text","text":"Iterative DFS (adjacency list)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"When you push a node onto the stack"},{"type":"text","text":", you're only checking if it's "},{"type":"text","marks":[{"type":"bold"}],"text":"not visited yet at that moment"},{"type":"text","text":". However, "},{"type":"text","marks":[{"type":"bold"}],"text":"the same node might get added to the stack multiple times"},{"type":"text","text":" through different paths before it is actually processed. Thats the reason why we check visited both at the beginning and before adding neighbor. Think 1 - 2 - 3 - 4 loop. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited nodes\nstack = [start]  # Initialize the stack with the starting node\n\nwhile stack:\n    node = stack.pop()  # Pop the last node added (LIFO order)\n\n    if node not in visited:\n        # Mark the node as visited\n        visited.add(node)\n        print(f\"Visiting node {node}\")\n\n        # Push all unvisited neighbors onto the stack\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-18","level":2},"content":[{"type":"text","text":"Iterative DFS (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited cells\nstack = [(start_x, start_y)]  # Initialize the stack with the starting cell\n\n# Define the directions for neighbors: up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Get the grid dimensions\nrows, cols = len(grid), len(grid[0])\n\nwhile stack:\n    x, y = stack.pop()  # Pop the last cell added\n\n    if (x, y) not in visited:\n        # Mark the current cell as visited\n        visited.add((x, y))\n        print(f\"Visiting cell ({x}, {y})\")\n\n        # Push all unvisited neighbors onto the stack (within bounds)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                stack.append((nx, ny))"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-19","level":2},"content":[{"type":"text","text":"Recursive DFS to keep track of Path (adjacency list)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"This works both in cyclic and acyclic graphs, as in the "},{"type":"text","marks":[{"type":"bold"}],"text":"backtracking step"},{"type":"text","text":", we are removing the node from the visited set once we finish exploring its neighbors. This prevents the algorithm from getting stuck in an infinite loop caused by cycles while still allowing revisits to nodes in different paths."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(node, target, graph, visited, path, all_paths):\n    visited.add(node)\n    path.append(node)\n    \n    if node == target:\n        # If we've reached the target, store the current path\n        all_paths.append(list(path))\n    else:\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, target, graph, visited, path, all_paths)\n    \n    path.pop()  # Backtrack\n    visited.remove(node)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-20","level":2},"content":[{"type":"text","text":"Recursive DFS to keep track of Path (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs(x, y, target_x, target_y, grid, visited, path, all_paths):\n    # Add current cell to the path and mark it as visited\n    path.append((x, y))\n    visited.add((x, y))\n    \n    # If we reach the target cell, store the current path\n    if (x, y) == (target_x, target_y):\n        all_paths.append(list(path))  # Store a copy of the path\n    else:\n        # Explore the 4 possible directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        rows, cols = len(grid), len(grid[0])\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            # Check if the next cell is within bounds and not visited\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 1:\n                dfs(nx, ny, target_x, target_y, grid, visited, path, all_paths)\n    \n    # Backtrack: remove the current cell from the path and unmark it as visited\n    path.pop()\n    visited.remove((x, y))"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-21","level":2},"content":[{"type":"text","text":"Recursive DFS for topological sort (Directed Graph)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Key point is, Once all neighbors of the current node have been processed, the current node is added to the stack."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"After performing DFS on all unvisited nodes, the stack will contain the nodes in reverse topological order (because nodes are pushed to the stack after their dependencies have been processed)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Result"},{"type":"text","text":": The topological order is obtained by reversing the stack."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Some important points: This code will only work if there is no cycle, i.e , incase of a DAG. If you want it to work even when cycles are there, and return empty array if cycles are there, you need to add cycle detection logic. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs_topological(node, graph, visited, stack):\n    visited.add(node)  # Mark the current node as visited\n\n    # Recursively visit all unvisited neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_topological(neighbor, graph, visited, stack)\n    \n    # After all neighbors are processed, add the current node to the stack\n    stack.append(node)\n\nvisited = set()  # Set to keep track of visited nodes\nstack = []  # Stack to store the topological order\n\n# Perform DFS from every node to ensure all nodes are visited\nfor node in range(n):\n    if node not in visited:\n        dfs_topological(node, graph, visited, stack)\n\n# The topological order is the reverse of the DFS post-order traversal\nreturn stack[::-1] "}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-22","level":2},"content":[{"type":"text","text":"Recursive DFS for Cycle Detection (Directed Graph)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Cycle detection is based on the Key point: In the current path, if there is back edge, i.e, node connecting to any previous nodes only in the current path, there is a cycle. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"You cannot use visited to keep track of cycles, i.e claim that if we revisit the node there is a cycle, as a node maybe visited multiple times in DFS. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"You also can't check something like if node in recursion_stack at the very beginning, because we will never visit the same node again due to us keeping track of visited. So that statement would never be True. So we always have to keep the main logic as detecting back edge. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs_cycle(node, graph, visited, recursion_stack):\n    visited.add(node)  # Mark the node as visited\n    recursion_stack.add(node)  # Add the node to the current recursion stack\n\n    # Explore the neighbors\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs_cycle(neighbor, graph, visited, recursion_stack):\n                return True  # Cycle detected (If you don't do this, True won't be propogated)\n        elif neighbor in recursion_stack:\n            return True  # Cycle detected (back edge found)\n\n    # Backtrack: remove the node from the recursion stack\n    recursion_stack.remove(node)\n    return False"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-23","level":2},"content":[{"type":"text","text":"BFS"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-24","level":2},"content":[{"type":"text","text":"BFS (adjacency list)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited nodes\nqueue = deque([start])  # Initialize the queue with the starting node\nvisited.add(start)  # Mark the start node as visited when enqueuing\n\nwhile queue:\n    node = queue.popleft()  # Dequeue the first node in the queue\n    print(f\"Visiting node {node}\")  # Process the node (e.g., print or collect data)\n\n    # Enqueue all unvisited neighbors and mark them as visited when enqueuing\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            queue.append(neighbor)\n            visited.add(neighbor)  # Mark as visited when enqueuing"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-25","level":2},"content":[{"type":"text","text":"BFS (grid)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set()  # To track visited cells\nqueue = deque([(start_x, start_y)])  # Initialize the queue with the starting cell\nvisited.add((start_x, start_y))  # Mark the start cell as visited when enqueuing\n\n# Define the directions for neighbors: up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nrows, cols = len(grid), len(grid[0])\n\nwhile queue:\n    x, y = queue.popleft()  # Dequeue the first cell\n    print(f\"Visiting cell ({x}, {y})\")  # Process the current cell\n\n    # Enqueue all unvisited valid neighbors\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n            queue.append((nx, ny))\n            visited.add((nx, ny))  # Mark as visited when enqueuing"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-26","level":2},"content":[{"type":"text","text":"Multisource BFS"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The multi-source BFS pattern is useful when you need to start BFS from multiple starting points simultaneously. This pattern ensures that all sources are explored in parallel, and it's commonly used in problems like finding the shortest distance from multiple sources to a destination."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The only change is from normal BFS code is that you add all the source nodes in the queue and call BFS"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-27","level":2},"content":[{"type":"text","text":"Maintaining Level information in BFS"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Simple way is just to maintain (node, level) instead of just node. Each time you are enqueuing new nodes, increment the level by 1. This way, you have level information for all the nodes. In this method, level information will be lost at the end, as the queue will become empty. It can still be used if you only need the end result, but if you need information like no. of nodes in each level etc., It is better to use level processing approach. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Other way is using array for levels, like so. Idea is to process nodes level by level, tracking the current level by processing all nodes at the same depth in one batch, and incrementing the level after processing each layer. Useful in tree problems (level order traversal) too."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"visited = set([start])  # Track visited nodes, starting with the source node\nqueue = deque([start])  # Queue to store nodes to be processed\nlevel = 0  # Start from level 0 (the level of the start node)\n\nwhile queue:\n    # Get the number of nodes at the current level\n    level_size = len(queue)\n    \n    # Process all nodes at the current level\n    for _ in range(level_size):\n        node = queue.popleft()  # Pop a node from the queue\n        print(f\"Node: {node}, Level: {level}\")\n        \n        # Add unvisited neighbors to the queue\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # After processing all nodes at the current level, increment the level\n    level += 1"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-28","level":2},"content":[{"type":"text","text":"BFS for topological sort (Cycle detection built in) (Kahn's algorithm)"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"graph = defaultdict(list)  # Adjacency list representation of the graph\nin_degree = [0] * n  # In-degree of each node\n\n# Build the graph and calculate in-degrees\nfor start, end in edges:\n    graph[start].append(end)\n    in_degree[end] += 1\n\n# Initialize the queue with all nodes that have in-degree of 0\nqueue = deque([i for i in range(n) if in_degree[i] == 0])\ntopo_order = []\n\nwhile queue:\n    node = queue.popleft()  # Get the node with zero in-degree\n    topo_order.append(node)  # Add it to the topological order\n    \n    # Reduce in-degree of all its neighbors\n    for neighbor in graph[node]:\n        in_degree[neighbor] -= 1\n        # If a neighbor now has in-degree of 0, add it to the queue\n        if in_degree[neighbor] == 0:\n            queue.append(neighbor)\n\n# If all nodes are processed, return the topological order, otherwise return empty (cycle detected)\nif len(topo_order) == n:\n    return topo_order\nelse:\n    return []  # Cycle detected"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-29","level":2},"content":[{"type":"text","text":"Eulerian Path/Cycle"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Eulerian Path"},{"type":"text","text":": If there is exactly one vertex with "},{"type":"text","marks":[{"type":"code"}],"text":"out-degree"},{"type":"text","text":" greater by 1 and one with "},{"type":"text","marks":[{"type":"code"}],"text":"in-degree"},{"type":"text","text":" greater by 1."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Eulerian Cycle"},{"type":"text","text":": If all vertices have equal "},{"type":"text","marks":[{"type":"code"}],"text":"in-degree"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"out-degree"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Basically Eulerian Path/Cycle means we cover all edges of a graph exactly once "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The algorithm is simple, we recursively keep removing edges one by one, so no need of visited set as we can revisit a node multiple times, but cannot revisit an edge. More elegant implementations also exist, but this should suffice for this rare problem. "}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dfs_eularian(node, graph, stack):\n    while graph[node]:\n        next_node = graph[node].pop(0) # Only if lexcial order pop(0), else its fine to pop any neighbor\n        dfs_eularian(next_node)\n    stack.append(node)\n\n# Start DFS from the determined starting airport\ndfs_eularian(start) # For determining start node, follow the instructions in the notes above.\nreturn stack[::-1]  # Reverse the itinerary to get the correct order"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-30","level":2},"content":[{"type":"text","text":"Disjoint Set Union / Union Find"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Purpose"},{"type":"text","text":": DSU is used to manage and merge disjoint sets, mainly in graph problems for tracking connected components and detecting cycles."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Operations"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Find"},{"type":"text","text":" with Path Compression: Reduces the time complexity by flattening the tree, so future operations are faster."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Union by Rank/Size"},{"type":"text","text":": Keeps the tree balanced by attaching the smaller tree under the root of the larger one."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Time Complexity"},{"type":"text","text":": Both "},{"type":"text","marks":[{"type":"code"}],"text":"find"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"union"},{"type":"text","text":" have nearly constant time complexity, due to path compression and union by rank"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Common Use Cases"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Cycle Detection"},{"type":"text","text":" in undirected graphs."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Kruskal’s MST Algorithm"},{"type":"text","text":" to avoid cycles when adding edges."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Connected Components"},{"type":"text","text":" to check if two nodes are in the same component."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Initialization"},{"type":"text","text":": Use two arrays—"},{"type":"text","marks":[{"type":"code"}],"text":"parent"},{"type":"text","text":" (each node points to itself initially) and "},{"type":"text","marks":[{"type":"code"}],"text":"rank"},{"type":"text","text":" (initially 0 for all nodes)."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"class DSU:\n    def __init__(self, n):\n        # Initialize parent and rank arrays\n        self.parent = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        '''\n        # Intialize parent and rank as dicts {} if no. of nodes is not known, and just add these lines of code\n        # Initialize parent and rank if node is encountered for the first time\n        if x not in self.parent:\n            self.parent[x] = x\n            self.rank[x] = 0\n        '''\n        # Find the root of the set containing x with path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        # Union by rank\n        root_x = self.find(x)\n        root_y = self.find(y)\n\n        if root_x != root_y:\n            # Attach smaller rank tree under root of the higher rank tree\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n    def connected(self, x, y):\n        # Check if two elements are in the same set\n        return self.find(x) == self.find(y)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-31","level":2},"content":[{"type":"text","text":"Minimum Spanning Trees (MST)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"An "},{"type":"text","marks":[{"type":"bold"}],"text":"MST"},{"type":"text","text":" connects all nodes in an undirected, weighted graph with the minimum possible total edge weight, ensuring there are no cycles and the graph remains fully connected."}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-32","level":2},"content":[{"type":"text","text":"MST Kruskal's"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Approach"},{"type":"text","text":": Edge-based, Greedy"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Process"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sort all edges in non-decreasing order by weight."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Initialize an empty MST and start adding edges from the sorted list."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"For each edge, check if it forms a cycle using DSU. If not, add it to the MST."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Repeat until the MST has V-1 exactly edges (where V is the number of vertices)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Best for"},{"type":"text","text":": Sparse graphs where sorting edges is manageable."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def kruskal_mst_fixed(edges):\n    # Initialize DSU and collect unique nodes to determine number of nodes\n    dsu = DynamicDSU()\n    unique_nodes = set(u for u, v, _ in edges).union(set(v for u, v, _ in edges))\n    num_nodes = len(unique_nodes)\n\n    # Sort edges by weight (ascending order)\n    edges.sort(key=lambda x: x[2])\n\n    mst = []  # To store edges in MST\n    total_cost = 0\n\n    # Iterate through sorted edges\n    for u, v, weight in edges:\n        # Only add edge if it doesn't form a cycle\n        if not dsu.connected(u, v):\n            dsu.union(u, v)  # Union the two vertices\n            mst.append((u, v, weight))  # Add edge to MST\n            total_cost += weight  # Add edge weight to total cost\n\n            # Stop if MST has enough edges (n - 1 edges for n nodes)\n            if len(mst) == num_nodes - 1:\n                break\n\n    return mst, total_cost"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-33","level":2},"content":[{"type":"text","text":"MST Prim's"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Approach"},{"type":"text","text":": Vertex-based, Greedy"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Process"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Start from any initial node."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a min-heap (priority queue) to track edges that extend from the MST."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Repeatedly pop the minimum edge from the heap:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"If it connects to an unvisited node, add it to the MST and add its neighbors to the heap."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Stop when the MST includes all nodes."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Best for"},{"type":"text","text":": Dense graphs with adjacency lists/matrices."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"# Redefining Prim's algorithm for MST with adjacency list input\ndef prim_mst(graph, start):\n    # Initialize structures\n    mst = []  # To store the edges in the MST\n    total_cost = 0  # To accumulate the total weight of the MST\n    visited = set()  # Track nodes already included in the MST\n    min_heap = []  # Priority queue (min-heap) for edges\n\n    # Function to add edges to the priority queue\n    def add_edges(node):\n        visited.add(node)\n        for neighbor, weight in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(min_heap, (weight, node, neighbor))\n\n    # Start from the initial node\n    add_edges(start)\n\n    # Process until MST includes all nodes or min-heap is empty\n    while min_heap and len(visited) < len(graph):\n        weight, u, v = heapq.heappop(min_heap)\n        if v not in visited:  # Only add edge if it connects to an unvisited node\n            mst.append((u, v, weight))\n            total_cost += weight\n            add_edges(v)  # Add edges from the newly added node\n\n    return mst, total_cost"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-34","level":2},"content":[{"type":"text","text":"Shortest Path Dijkstra"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Approach"},{"type":"text","text":": Single-source shortest path for non-negative weights"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Process"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Initialize distances from the start node to all other nodes as infinity (except for the start, set to 0)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a min-heap to manage nodes by their current shortest distance."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Pop the node with the smallest distance:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"For each neighbor, calculate the potential new distance."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"If this distance is shorter than the known distance, update it and push the neighbor with the updated distance."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Continue until all reachable nodes have the shortest path from the start."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Best for"},{"type":"text","text":": Shortest paths in non-negative weighted graphs."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def dijkstra(graph, start):\n    # Initialize distance dictionary with infinity for all nodes except the start\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    # Priority queue (min-heap) initialized with the starting node\n    min_heap = [(0, start)]  # (distance, node)\n\n    while min_heap:\n        # Pop the node with the smallest distance\n        current_distance, u = heapq.heappop(min_heap)\n\n        # Process only if the current distance is the smallest known distance for u\n        if current_distance > distances[u]:\n            continue\n\n        # Check each neighbor of the current node\n        for v, weight in graph[u]:\n            distance = current_distance + weight  # Calculate potential new distance to neighbor\n\n            # Only consider this path if it's shorter than the known distance\n            if distance < distances[v]:\n                distances[v] = distance  # Update to the shorter distance\n                heapq.heappush(min_heap, (distance, v))  # Push updated distance into the heap\n\n    return distances"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-35","level":2},"content":[{"type":"text","text":"Tips and Tricks to Solve graph problems"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"To detect length of cycle or elements in cycle, you can keep track of entry times in the recursive_stack. This can also help you in finding the exact cycle. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"For "},{"type":"text","marks":[{"type":"bold"}],"text":"undirected graphs"},{"type":"text","text":", cycles are found using DSU or DFS with back edges. For "},{"type":"text","marks":[{"type":"bold"}],"text":"directed graphs"},{"type":"text","text":", cycles are detected through "},{"type":"text","marks":[{"type":"bold"}],"text":"DFS with recursion stack tracking"},{"type":"text","text":"."}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-36","level":1},"content":[{"type":"text","text":"Dynamic Programming"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"General tip - In bottom up DP, if 2D DP, draw the matrix and visualize the dependencies, becomes easier."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sometime memoization is more intuitive, sometime DP is more intuitive. DP you can usually perform space optimization. "}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-37","level":2},"content":[{"type":"text","text":"0/1 Knapsack Pattern - "}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def knapsack(values, weights, capacity):\n    n = len(values)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):  # For each item\n        for w in range(1, capacity + 1):  # For each capacity\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]) #i-1 is the actual item\n            else:\n                dp[i][w] = dp[i - 1][w]\n    \n    return dp[n][capacity]"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-38","level":2},"content":[{"type":"text","text":"Unbounded Knapsack Patten - 322, 343, 279"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def unbounded_knapsack(values, weights, capacity):\n    n = len(values)\n    dp = [0] * (capacity + 1)\n    \n    # Fill the DP array\n    for i in range(n):  # For each item\n        for w in range(weights[i], capacity + 1):  # For each capacity\n            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])\n    \n    return dp[capacity]"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Coin Change II - Since ordering doesnt matter, it is a 2 state problem instead of 1 state. little tricky to catch. You use inclusion/exclusion decision tree, memoization solution is simple to implement. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"If ordering does matter, then it is a simple 1 state solution like Coin Change I"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-39","level":2},"content":[{"type":"text","text":"Fibonacci"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The Fibonacci pattern shows up in many dynamic programming problems where each state depends on a fixed number of previous states."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def fibonacci_dp(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-40","level":2},"content":[{"type":"text","text":"Longest Palindromic Substring"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"If you know that a substring "},{"type":"text","marks":[{"type":"code"}],"text":"s[l+1:r-1]"},{"type":"text","text":" is a palindrome, then "},{"type":"text","marks":[{"type":"code"}],"text":"s[l:r]"},{"type":"text","text":" is also a palindrome if "},{"type":"text","marks":[{"type":"code"}],"text":"s[l] == s[r]"},{"type":"text","text":"."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"In problems involving "},{"type":"text","marks":[{"type":"bold"}],"text":"palindromic substrings or subsequences"},{"type":"text","text":", the goal is often to:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Identify the longest palindromic substring"},{"type":"text","text":" (continuous sequence)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Count the number of palindromic substrings"},{"type":"text","text":"."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Find the longest palindromic subsequence"},{"type":"text","text":" (which doesn’t need to be contiguous)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Important: Diagonal Filling of the matrix"}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def longestPalindrome(self, s: str) -> str:\nn= len(s)\ndp = [[False]*n for _ in range(n)]\n\nfor i in range(n):\n    dp[i][i] = True\nans = [0,0]\n\nfor i in range(n - 1):\n    if s[i] == s[i + 1]:\n        dp[i][i + 1] = True\n        ans = [i, i + 1]\n\nfor i in range(n-1, -1, -1):\n    for j in range(n-1, -1, -1):\n        if j<=i+1:\n            continue\n        if s[i]==s[j] and dp[i+1][j-1]:\n            dp[i][j] = True\n            if j-i>ans[1]-ans[0]:\n                ans = [i,j]\nreturn s[ans[0]:ans[1]+1]"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-41","level":2},"content":[{"type":"text","text":"Maximum Sum/Product Subarrays"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def max_subarray_sum(nums):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef maxProduct(nums):\n        prev_max, prev_min = nums[0], nums[0]\n        ans=prev_max\n        for i in range(1,len(nums)):\n            curr_max = max(nums[i], nums[i]*prev_max, nums[i]*prev_min)\n            curr_min = min(nums[i], nums[i]*prev_max, nums[i]*prev_min)\n            prev_max, prev_min = curr_max, curr_min\n            ans = max(ans, prev_max)\n        return ans"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-42","level":2},"content":[{"type":"text","text":"Word Break"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"#O(n^2), dp[i] represents if word till i can be broken into parts. Important problem as you need to check all previous indices. "}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-43","level":2},"content":[{"type":"text","text":"Longest Increasing Subsequence"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The "},{"type":"text","marks":[{"type":"bold"}],"text":"Longest Increasing Subsequence (LIS) Pattern"},{"type":"text","text":" is a common dynamic programming pattern used to find subsequences within a sequence that meet certain increasing criteria. This pattern typically involves identifying or counting "},{"type":"text","marks":[{"type":"bold"}],"text":"subsequences"},{"type":"text","text":" (not necessarily contiguous) that satisfy conditions related to increasing order, longest length, or specific values."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Define the DP Array"},{"type":"text","text":": Use an array "},{"type":"text","marks":[{"type":"code"}],"text":"dp"},{"type":"text","text":" where "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i]"},{"type":"text","text":" represents the length of the longest increasing subsequence ending at index "},{"type":"text","marks":[{"type":"code"}],"text":"i"},{"type":"text","text":"."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Transition"},{"type":"text","text":": For each element "},{"type":"text","marks":[{"type":"code"}],"text":"i"},{"type":"text","text":", check all previous elements "},{"type":"text","marks":[{"type":"code"}],"text":"j < i"},{"type":"text","text":". If "},{"type":"text","marks":[{"type":"code"}],"text":"nums[j] < nums[i]"},{"type":"text","text":", update "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i] = max(dp[i], dp[j] + 1)"},{"type":"text","text":" to extend the subsequence ending at "},{"type":"text","marks":[{"type":"code"}],"text":"j"},{"type":"text","text":"."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Important"},{"type":"text","text":": O(nlogn) Use "},{"type":"text","marks":[{"type":"code"}],"text":"tails"},{"type":"text","text":" to store the smallest ending of increasing subsequences. For each "},{"type":"text","marks":[{"type":"code"}],"text":"num"},{"type":"text","text":", use binary search to find its position in "},{"type":"text","marks":[{"type":"code"}],"text":"tails"},{"type":"text","text":" – replace if within bounds, or append if beyond (is the last element)"}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def length_of_lis(nums):\n    \n    dp = [1] * len(nums)  # Each element is at least an increasing subsequence of length 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-44","level":2},"content":[{"type":"text","text":"Counting Paths/Combinations Pattern"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Goal"},{"type":"text","text":": Given a target, find distinct ways to reach it based on given moves/rules."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"DP Array/Table"},{"type":"text","text":": Use "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i]"},{"type":"text","text":" or "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i][j]"},{"type":"text","text":" to store the count of ways to reach each target or cell."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Common Formula"},{"type":"text","text":": For each "},{"type":"text","marks":[{"type":"code"}],"text":"i"},{"type":"text","text":", update "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i]"},{"type":"text","text":" by summing counts from preceding states based on allowed moves."}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-45","level":4},"content":[{"type":"text","text":"Key Examples"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Climbing Stairs"},{"type":"text","text":": "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i] = dp[i-1] + dp[i-2]"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Coin Change (Combinations)"},{"type":"text","text":": "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i] += dp[i - coin]"},{"type":"text","text":" for each coin"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Grid Unique Paths"},{"type":"text","text":": "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i][j] = dp[i-1][j] + dp[i][j-1]"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-46","level":2},"content":[{"type":"text","text":"Longest Common Subsequence (LCS) Pattern"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Goal"},{"type":"text","text":": Compare two sequences and find:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Length of Longest Common Subsequence (LCS)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Minimum edits to transform one sequence into another (Edit Distance)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Longest contiguous substring (Longest Common Substring)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Idea"},{"type":"text","text":": Use a 2D DP table "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i][j]"},{"type":"text","text":" where:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"dp[i][j]"},{"type":"text","text":" represents the result for substrings "},{"type":"text","marks":[{"type":"code"}],"text":"s1[:i]"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"s2[:j]"},{"type":"text","text":"."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Cases"},{"type":"text","text":": If "},{"type":"text","marks":[{"type":"code"}],"text":"i == 0"},{"type":"text","text":" or "},{"type":"text","marks":[{"type":"code"}],"text":"j == 0"},{"type":"text","text":", the result is "},{"type":"text","marks":[{"type":"code"}],"text":"0"},{"type":"text","text":" (empty string)."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def longest_common_subsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-47","level":3},"content":[{"type":"text","text":"Variants"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Edit Distance"},{"type":"text","text":": Modify "},{"type":"text","marks":[{"type":"code"}],"text":"dp[i][j]"},{"type":"text","text":" transition to consider insert, delete, substitute. Also modify to correct base case. "}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(1 if s1[i-1]!=s2[j-1] else 0))"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Longest Common Substring"},{"type":"text","text":": If characters match, add "},{"type":"text","marks":[{"type":"code"}],"text":"+1"},{"type":"text","text":" to previous diagonal:"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = 0"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-48","level":2},"content":[{"type":"text","text":"State based DP Pattern"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Goal"},{"type":"text","text":": Optimize decisions across states influenced by actions (e.g., buying/selling, resting/working)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Idea"},{"type":"text","text":": Define "},{"type":"text","marks":[{"type":"bold"}],"text":"states"},{"type":"text","text":" to track situations (e.g., holding stock, not holding, cooldown) and "},{"type":"text","marks":[{"type":"bold"}],"text":"transition equations"},{"type":"text","text":" between states."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Steps"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Identify "},{"type":"text","marks":[{"type":"bold"}],"text":"states"},{"type":"text","text":" based on possible actions."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Draw a "},{"type":"text","marks":[{"type":"bold"}],"text":"state diagram"},{"type":"text","text":" to visualize transitions."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Write "},{"type":"text","marks":[{"type":"bold"}],"text":"recurrence relations"},{"type":"text","text":" for each state based on dependencies."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Base Cases"},{"type":"text","text":": Define initial conditions (e.g., starting with no stock or zero profit)."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def state_based_dp_problem(prices):\n    # Base cases (initial states)\n    hold = -prices[0]   # Max profit when holding stock on day 0\n    not_hold = 0        # Max profit when not holding stock on day 0\n    cooldown = 0        # Max profit in cooldown on day 0\n\n    for i in range(1, len(prices)):\n        prev_hold = hold\n        # State transitions\n        hold = max(hold, not_hold - prices[i])        # Continue holding or buy today\n        not_hold = max(not_hold, cooldown)           # Continue not holding or end cooldown\n        cooldown = prev_hold + prices[i]             # Sell today and enter cooldown\n\n    # Final result: max profit can be in not_hold or cooldown\n    return max(not_hold, cooldown)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-49","level":2},"content":[{"type":"text","text":"Todo"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Negative marking "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Prefix Sum + Hashmap pattern (also modulo if involved)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sliding window + Hashmap (also using matched variable to avoid hashmap)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Monotonic Stack"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"QuickSelect Algorithm "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Storing index as key in hashmap (Problem #3 leetcode)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sliding window - complement of sliding window pattern "},{"type":"text","marks":[{"type":"link","attrs":{"href":"https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/","target":"_blank","rel":"noopener noreferrer nofollow","class":"no-underline hover:text-blue-s dark:hover:text-dark-blue-s truncate cursor-text whitespace-normal hover:!text-[inherit]"}},{"type":"bold"}],"text":"2516. Take K of Each Character From Left and Right"}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-50","level":1},"content":[{"type":"text","text":"Arrays + Hashmaps"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-51","level":2},"content":[{"type":"text","text":"QuickSelect "}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Use Cases"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Kth largest/smallest element"},{"type":"text","text":" or "},{"type":"text","marks":[{"type":"bold"}],"text":"Top K elements"},{"type":"text","text":" in O(n) average time."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Avoids full sorting for subset problems (better than nlogn)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Insight"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Partition around a "},{"type":"text","marks":[{"type":"bold"}],"text":"pivot"},{"type":"text","text":" to partially sort: left satisfies the comparator, pivot lands in its correct position."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"How to Use"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Set "},{"type":"text","marks":[{"type":"code"}],"text":"k = k - 1"},{"type":"text","text":" for 0-based indexing."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use "},{"type":"text","marks":[{"type":"code"}],"text":"x >= y"},{"type":"text","text":" for "},{"type":"text","marks":[{"type":"bold"}],"text":"descending order"},{"type":"text","text":" (Kth largest, Top K)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use "},{"type":"text","marks":[{"type":"code"}],"text":"x <= y"},{"type":"text","text":" for "},{"type":"text","marks":[{"type":"bold"}],"text":"ascending order"},{"type":"text","text":" (Kth smallest, Bottom K)."}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def quickselect(arr, left, right, k, comparator):\n    def partition(arr, left, right):\n        pivot = arr[right]  # Choose the last element as pivot\n        p = left  # Pointer for elements satisfying comparator\n        for i in range(left, right):\n            if comparator(arr[i], arr[right]):  # Compare with pivot\n                arr[i], arr[p] = arr[p], arr[i]\n                p += 1\n        arr[p], arr[right] = arr[right], arr[p]  # Place pivot in position\n        return p\n\n    if left <= right:\n        pivot_index = partition(arr, left, right)\n        if pivot_index == k:  # Found the Kth element\n            return arr[pivot_index]\n        elif pivot_index < k:  # Look for Kth in the right part\n            return quickselect(arr, pivot_index + 1, right, k, comparator)\n        else:  # Look for Kth in the left part\n            return quickselect(arr, left, pivot_index - 1, k, comparator)\n\n# Comparator for kth largest and top k elements \ncomparator = lambda x, y: x >= y\n\n# Comparator for kth smallest and bottom k elements \ncomparator = lambda x, y: x <= y"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-52","level":2},"content":[{"type":"text","text":"Prefix Sum (Prefix Sum, Prefix Sum+Binary Search, Prefix Sum+Hashmaps)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Idea"},{"type":"text","text":": Combine prefix sums with a hashmap to store cumulative sums and solve subarray problems dynamically."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"code"}],"text":"prefix[i] - prefix[j] = k => prefix[j] = prefix[i] - k"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Use Cases"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Count subarrays with specific conditions (e.g., sum equals k)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Modular conditions (e.g., divisible by k)."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Important points: "},{"type":"text","marks":[{"type":"bold"}],"text":"Particularly useful when sliding window approaches fail (because of presence of negative numbers), If only +ve numbers are present, prefix_sum array is sorted, can think if binary search is needed."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def prefix_sum_with_hashmap(arr, k):\n    prefix = 0\n    count = 0\n    hashmap = {0: 1}  # Initialize with prefix 0 to handle exact matches\n    \n    for num in arr:\n        prefix += num\n        # Check if prefix - k exists in the hashmap\n        if (prefix - k) in hashmap:\n            count += hashmap[prefix - k]\n        # Update the hashmap with the current prefix\n        hashmap[prefix] = hashmap.get(prefix, 0) + 1\n    \n    return count"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-53","level":2},"content":[{"type":"text","text":"Hashsets (Building consecutive sequences pattern)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-54","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Idea"},{"type":"text","text":":"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a "},{"type":"text","marks":[{"type":"code"}],"text":"HashSet"},{"type":"text","text":" for:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Quick lookups for presence/absence."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Ensuring uniqueness of elements."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problems involving element relationships (e.g., consecutive sequences)."}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def longest_consecutive(nums):\n  \n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Check if it's the start of a sequence\n        if num - 1 not in num_set:\n            length = 0\n            current = num\n            while current in num_set:\n                length += 1\n                current += 1\n            longest = max(longest, length)\n    \n    return longest"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-55","level":2},"content":[{"type":"text","text":"Sorting"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"# 1. Sort in Ascending Order\narr.sort()  # [1, 3, 5, 8]\n\n# 2. Sort in Descending Order\narr.sort(reverse=True)  # [8, 5, 3, 1]\n\n# 3. Sort by the Second Element in a Tuple\narr.sort(key=lambda x: x[1])  # [(3, 1), (1, 2), (2, 3)]\n\n# 4. Sort by Length of Strings\narr.sort(key=lambda x: len(x))  # ['kiwi', 'apple', 'banana']\n\n# 5. Sort by Multiple Keys (Primary Ascending, Secondary Descending)\narr.sort(key=lambda x: (x[0], -x[1]))  # [(1, 3), (1, 2), (2, 3), (2, 2)]\n\n# 6. Sort by the second element in a tuple using sorted()\nsorted_arr = sorted(arr, key=lambda x: x[1])  # [(3, 1), (1, 2), (2, 3)]"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-56","level":2},"content":[{"type":"text","text":"Negative Marking"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The problem involves integers bounded by the size of the array (e.g., values from 1 to n). "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"You’re asked to find duplicates, missing elements, or cycles in O(n) time and O(1) space. "}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"The input array can be modified in-place."}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def find_duplicates(nums): #nums has only values 1 to n\n    res = []\n    for num in nums:\n        index = abs(num) - 1  # Map value to index\n        if nums[index] < 0:\n            res.append(abs(num))  # Already marked negative -> duplicate\n        else:\n            nums[index] = -nums[index]  # Mark as visited\n    return res"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-57","level":2},"content":[{"type":"text","text":"Majority Element (Boyer-Moore Voting Algorithm + Hashmap Alternative)"}]},{"type":"orderedList","attrs":{"tight":true,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Candidate votes for itself, all other candidates vote against it"}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def majority_element(nums):\n   \n    # Step 1: Find the candidate\n    candidate, count = None, 0\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-58","level":1},"content":[{"type":"text","text":"2 pointers"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-59","level":2},"content":[{"type":"text","text":"Opposite Direction Two Pointers"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sorting may be useful if not explicitly prohibited"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"In the "},{"type":"text","marks":[{"type":"bold"}],"text":"Opposite Direction Two Pointers"},{"type":"text","text":" pattern, two pointers are initialized at opposite ends of a list or array, and they are moved toward each other based on conditions to solve a problem. This approach is widely applicable to problems involving sorted arrays, searching for optimal solutions, or evaluating complex conditions involving multiple indices."}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use "},{"type":"text","marks":[{"type":"code"}],"text":"l < r"},{"type":"text","text":": For problems comparing pairs of elements where overlapping isn't meaningful (most problems, 2 sum sorted etc). Use "},{"type":"text","marks":[{"type":"code"}],"text":"l <= r"},{"type":"text","text":": For problems where overlapping or single element checks are necessary (palindrome check). "}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def opposite_direction_two_pointers(arr, condition):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        # Perform actions based on condition\n        if condition(arr[left], arr[right]):\n            # Example: process a valid pair\n            process(arr[left], arr[right])\n        \n        # Update pointers based on the problem logic\n        if move_left_condition:  # Replace with actual condition\n            left += 1\n        elif move_right_condition:  # Replace with actual condition\n            right -= 1\n        else:\n            # Break if no further action is possible\n            break"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-60","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"General Problem Categories"}]},{"type":"orderedList","attrs":{"tight":false,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Simple Conditions"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problems with straightforward conditions for moving pointers (e.g., sums, comparisons, or matching characters)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Examples"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Two-Sum in a sorted array."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Checking if a string is a palindrome."}]}]}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Complex Conditions"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problems where the condition to move pointers involves more elaborate calculations or logic."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Examples"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Maximizing or minimizing values (e.g., Container with Most Water)."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Aggregating values across the pointers (e.g., Trapping Rain Water)."}]}]}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Advanced Applications"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Problems that incorporate sorting or nested loops (e.g., counting triplets or evaluating multiple conditions)"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Examples:"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Valid triangle number, 3-sum"}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Note: Was not able to solve 3-sum ("},{"type":"text","marks":[{"type":"bold"}],"text":"including all duplicates"},{"type":"text","text":") using this method"}]}]}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def opposite_direction_with_sorting(arr):\n    # Step 1: Sort the array if needed\n    arr.sort()\n\n    # Step 2: Iterate through the array with one fixed pointer\n    for i in range(len(arr)):\n        left, right = i + 1, len(arr) - 1 #Can be adjusted, you can start at end of array too, like Valid triangle\n        \n        # Step 3: Use two pointers to evaluate the condition\n        while left < right:\n            if condition(arr[i], arr[left], arr[right]): \n                process(arr[i], arr[left], arr[right])\n                # Adjust pointers based on requirements\n                left += 1\n                right -= 1\n            elif adjust_left_condition:  # Example condition to move left\n                left += 1\n            else:  # Adjust right\n                right -= 1"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-61","level":2},"content":[{"type":"text","text":"Same Direction Pointers (Not Sliding Window)"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"This pattern involves two pointers ("},{"type":"text","marks":[{"type":"code"}],"text":"left"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"right"},{"type":"text","text":") that move in the same direction. The "},{"type":"text","marks":[{"type":"bold"}],"text":"right pointer"},{"type":"text","text":" moves first until a condition is met or unmet. Once the condition changes, the "},{"type":"text","marks":[{"type":"bold"}],"text":"left pointer"},{"type":"text","text":" is adjusted to the position of the right pointer. This is "},{"type":"text","marks":[{"type":"bold"}],"text":"not a sliding window"},{"type":"text","text":" since the left pointer does not increment gradually but instead jumps to match the right pointer."}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-62","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Key Insights"}]},{"type":"orderedList","attrs":{"tight":false,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Right Pointer Moves First"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Start with "},{"type":"text","marks":[{"type":"code"}],"text":"left"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"right"},{"type":"text","text":" at the same position."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Increment "},{"type":"text","marks":[{"type":"code"}],"text":"right"},{"type":"text","text":" while evaluating a condition."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Adjust Left Pointer"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"When the condition is violated or met, bring the "},{"type":"text","marks":[{"type":"code"}],"text":"left"},{"type":"text","text":" pointer to match the "},{"type":"text","marks":[{"type":"code"}],"text":"right"},{"type":"text","text":" pointer."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Non-Overlapping Subarrays"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"This pattern ensures that the ranges between "},{"type":"text","marks":[{"type":"code"}],"text":"left"},{"type":"text","text":" and "},{"type":"text","marks":[{"type":"code"}],"text":"right"},{"type":"text","text":" pointers are disjoint or non-overlapping."}]}]}]}]}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def same_direction_pointers(arr):\n    left = 0\n    right = 0\n    while right < len(arr):\n        # Expand the right pointer\n        while right < len(arr) and condition(arr[right]):\n            #Can have complex logic here instead of having condition above\n            right += 1\n        \n        # Process the range [left, right)\n        process(arr[left:right])\n        \n        # Increment right pointer by 1 to start new window\n        right+=1\n        # Move the left pointer to match the right\n        left = right"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-63","level":4},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Common Applications"}]},{"type":"orderedList","attrs":{"tight":false,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Splitting Strings or Arrays"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Breaking a sequence into segments based on a condition."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Processing Subarrays"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Analyze non-overlapping subarrays meeting specific criteria."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Counting or Extracting Ranges"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Count segments, extract substrings, or find subarrays."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Skipping Invalid Values"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Handle sequences with gaps or delimiters by skipping invalid parts."}]}]}]}]}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-64","level":2},"content":[{"type":"text","text":"Three pointers"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Basically partition array into three groups by some conditions."}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def sort_colors(nums):\n    p1, p2, p3 = 0, 0, len(nums) - 1\n\n    while p2 <= p3:\n        if nums[p2] == 0:  # Move 0s to the left\n            nums[p1], nums[p2] = nums[p2], nums[p1]\n            p1 += 1\n            p2 += 1\n        elif nums[p2] == 1:  # Keep 1s in the middle\n            p2 += 1\n        else:  # Move 2s to the right\n            nums[p2], nums[p3] = nums[p3], nums[p2]\n            p3 -= 1"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-65","level":2},"content":[{"type":"text","text":"Pattern: Two Pointers on Two Different Arrays/Strings"}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"This pattern involves using two pointers, each operating on a separate array or string. The pointers traverse independently or interact based on specific conditions to solve a problem efficiently."}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def two_pointers_on_two_arrays(arr1, arr2):\n    # Initialize two pointers\n    i, j = 0, 0\n    result = []\n\n    while i < len(arr1) and j < len(arr2):\n        if condition(arr1[i], arr2[j]):\n            process(arr1[i], arr2[j], result)\n            i += 1\n            j += 1\n        elif adjust_pointer_1_condition:\n            i += 1\n        else:\n            j += 1\n\n    # Process remaining elements if required\n    while i < len(arr1):\n        process(arr1[i], None, result)\n        i += 1\n    while j < len(arr2):\n        process(None, arr2[j], result)\n        j += 1\n\n    return result"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-66","level":2},"content":[{"type":"text","text":"Pattern: Fast and Slow Pointers on Arrays (Tortoise and Hare) "}]},{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Just writing it down here, not very important, revisit if you have time. 2 problems - LeetCode 457: Circular Array Loop, LeetCode 202: Happy Number"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-67","level":1},"content":[{"type":"text","text":"Sliding Window"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-68","level":2},"content":[{"type":"text","text":"Fixed Size"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"def fixed_size_sliding_window(arr, k):\n    n = len(arr)\n    window_sum = 0\n    result = []\n\n    # Initialize the first window\n    for i in range(k):\n        window_sum += arr[i]\n    \n    # Append the result of the first window\n    result.append(window_sum)\n\n    # Slide the window across the array\n    for i in range(k, n):\n        window_sum += arr[i] - arr[i - k]  # Add the next element, remove the first element of the previous window\n        result.append(window_sum)\n    \n    return result"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-69","level":2},"content":[{"type":"text","text":"Dynamic Size"}]},{"type":"codeBlock","attrs":{"language":"python","collapsed":false},"content":[{"type":"text","text":"l = 0\nfor r in range(len(nums)):\n    # Expand window by adding nums[r]\n    update_window(nums[r])\n\n    # Shrink window if condition is violated\n    while condition_not_met():\n        # Update result if required inside the loop (e.g., for min problems)\n        update_window_on_shrink(nums[l])\n        l += 1\n\n    # Update result if required outside the loop (e.g., for max problems)\n    update_result(l, r)"}]},{"type":"heading","attrs":{"textAlign":"left","id":"heading-70","level":3},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Dynamic Sliding Window Notes"}]},{"type":"orderedList","attrs":{"tight":false,"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"General Rules"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use two pointers ("},{"type":"text","marks":[{"type":"code"}],"text":"l"},{"type":"text","text":", "},{"type":"text","marks":[{"type":"code"}],"text":"r"},{"type":"text","text":"): expand with "},{"type":"text","marks":[{"type":"code"}],"text":"r"},{"type":"text","text":", shrink with "},{"type":"text","marks":[{"type":"code"}],"text":"l"},{"type":"text","text":"."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Update result inside "},{"type":"text","marks":[{"type":"code"}],"text":"while"},{"type":"text","text":" if intermediate windows matter (e.g., "},{"type":"text","marks":[{"type":"bold"}],"text":"min problems"},{"type":"text","text":")."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Update result after "},{"type":"text","marks":[{"type":"code"}],"text":"while"},{"type":"text","text":" if only the final window matters (e.g., "},{"type":"text","marks":[{"type":"bold"}],"text":"max problems"},{"type":"text","text":")."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Sliding Window + HashMap/Set"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a hashmap/set to track element frequencies or uniqueness."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Shrink when the hashmap/set exceeds constraints (e.g., distinct elements > "},{"type":"text","marks":[{"type":"code"}],"text":"k"},{"type":"text","text":")."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Index Trick (Last Occurrence)"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a hashmap to store the last occurrence of an element."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Update "},{"type":"text","marks":[{"type":"code"}],"text":"l"},{"type":"text","text":" to "},{"type":"text","marks":[{"type":"code"}],"text":"max(l, last_occurrence + 1)"},{"type":"text","text":" to skip invalid windows."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Matches Trick (Two HashMaps)"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use two hashmaps and a "},{"type":"text","marks":[{"type":"code"}],"text":"matches"},{"type":"text","text":" variable to track when the window satisfies the target hashmap."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Increment "},{"type":"text","marks":[{"type":"code"}],"text":"matches"},{"type":"text","text":" when counts match; decrement on invalid shrink."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Sliding Window + Prefix Sum"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use prefix sums to compute subarray sums efficiently."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Track prefix sums in a hashmap for difference-based lookups."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Sliding Window + Deque"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Use a deque to maintain a monotonic order of indices/values in the window."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Useful for problems like finding max/min in a sliding window."}]}]}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","marks":[{"type":"bold"}],"text":"Quirks and Edge Cases"},{"type":"text","text":":"}]},{"type":"bulletList","attrs":{"tight":true},"content":[{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"For substring problems, slicing ("},{"type":"text","marks":[{"type":"code"}],"text":"s[l:r+1]"},{"type":"text","text":") is useful."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Sliding window can combine with binary search for length checks."}]}]},{"type":"listItem","content":[{"type":"paragraph","attrs":{"textAlign":"left"},"content":[{"type":"text","text":"Two-pass sliding window works when expansion and shrinking need separate logic."}]}]}]}]}]},{"type":"paragraph","attrs":{"textAlign":"left"}}]}